---
- name: Check and apply RDS pending maintenance with scheduled time and email alerts
  hosts: localhost
  gather_facts: false

  vars:
    rds_instance_id: "your-rds-instance-id"
    aws_region: "your-aws-region"
    email_recipients: "recipient@example.com"
    email_sender: "sender@example.com"
    email_smtp_server: "smtp.example.com"
    email_smtp_port: 587
    email_subject_prefix: "[RDS Maintenance Notification]"
    scheduled_time: "2024-08-19 02:45:00"  # Set the scheduled time in UTC

  tasks:
    - name: Check for pending maintenance actions
      aws_rds_info:
        db_instance_identifier: "{{ rds_instance_id }}"
        region: "{{ aws_region }}"
      register: rds_info

    - name: Extract pending maintenance actions
      set_fact:
        pending_maintenance: "{{ rds_info.db_instances[0].pending_modified_values | default([]) }}"

    - name: Send email alert before applying maintenance
      mail:
        host: "{{ email_smtp_server }}"
        port: "{{ email_smtp_port }}"
        from: "{{ email_sender }}"
        to: "{{ email_recipients }}"
        subject: "{{ email_subject_prefix }} Pending RDS Maintenance on {{ rds_instance_id }}"
        body: |
          The following pending maintenance actions were found for RDS instance {{ rds_instance_id }}:
          {{ pending_maintenance | to_nice_json }}
          
          The maintenance is scheduled to be applied at {{ scheduled_time }} (UTC).
      when: pending_maintenance | length > 0

    - name: Wait until the scheduled time before applying maintenance
      when: pending_maintenance | length > 0
      wait_for:
        timeout: "{{ (ansible_date_time.iso8601 | to_datetime('%Y-%m-%dT%H:%M:%SZ') | diff(scheduled_time | to_datetime('%Y-%m-%d %H:%M:%S'))).total_seconds() | int }}"
        state: present
      delegate_to: localhost

    - name: Apply pending maintenance if available
      when: pending_maintenance | length > 0
      aws_rds:
        db_instance_identifier: "{{ rds_instance_id }}"
        apply_immediately: yes
      register: rds_apply

    - name: Send email alert after applying maintenance
      mail:
        host: "{{ email_smtp_server }}"
        port: "{{ email_smtp_port }}"
        from: "{{ email_sender }}"
        to: "{{ email_recipients }}"
        subject: "{{ email_subject_prefix }} RDS Maintenance Applied on {{ rds_instance_id }}"
        body: |
          The pending maintenance actions have been successfully applied to RDS instance {{ rds_instance_id }}.
          
          Maintenance Details:
          {{ rds_apply | to_nice_json }}
      when: pending_maintenance | length > 0

    
Introduction to My MicroK8s Deployment
MicroK8s is a lightweight version of Kubernetes, perfect for setting up quickly and managing containers without a lot of hassle. It’s ideal for both development and production because it doesn’t require heavy resources and is easy to configure.

Overview of My MicroK8s Setup
Here’s a breakdown of how my MicroK8s setup is organized:

Server Groups:

I’ve organized my servers into groups, like masters, workers, and kops_hosts. These groups are defined in a YAML file (inv_development.yml), making it easier to manage and keep track of them.
Master and Worker Nodes:

The setup includes both master nodes (which control the cluster) and worker nodes (which run the applications). These nodes are spread across different availability zones to ensure high availability. If one zone goes down, the others keep running smoothly.
DNS and Load Balancing:

I use DNS round-robin (like kube-api-dev02) to balance the load between the master nodes. This setup ensures that requests are distributed evenly, preventing any single master node from getting overloaded.
Ansible Automation:

To automate the deployment and configuration of my MicroK8s clusters, I use Ansible playbooks. These playbooks specify everything, from which servers are masters or workers to what resources they should use.
Provisioning EC2 Instances:

I use templates to automatically create and set up EC2 instances in my AWS environment. This makes it easy to deploy new servers with all the necessary software and configurations in place.
Testing and Validation:

After setting up, I run test cases to ensure everything is working as expected. For example, I check that the MicroK8s installation is successful and that the DNS records are correctly created for each master node.
Production Environment:

In production, I’ve set up multiple master and worker nodes to handle real-world workloads. This ensures that my system is robust, scalable, and ready for any demand.
This setup helps me manage my Kubernetes clusters efficiently, with automation taking care of most of the heavy lifting, and ensures that everything runs smoothly even in the face of unexpected issues.
